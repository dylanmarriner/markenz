/**
 * File: crates/events/src/observation_event.rs
 * 
 * Purpose: Defines ObservationEvent schema for Phase 0 deterministic state change tracking
 * 
 * Why this file exists: 
 * - ObservationEvent provides immutable audit trail of all state changes
 * - Enables deterministic replay verification by comparing before/after states
 * - Supports hash-chain integrity verification for world state mutations
 * 
 * Phase plan authority: MARKENZ_GOVERNANCE_PHASE_0_REPO_AND_EVENT_LOG_BASELINE.md
 * 
 * Invariants enforced:
 * - Every ObservationEvent records exact state transition (before → after)
 * - Hash computation is deterministic and verifiable
 * - State diffs are immutable and append-only
 * - Links InputEvents to their observable effects
 * 
 * What breaks if removed:
 * - No audit trail of state changes → cannot verify what actually happened
 * - No replay verification → cannot detect determinism violations
 * - No state diff tracking → impossible to debug or audit system behavior
 * 
 * What this file does NOT do:
 * - Does not implement state mutation logic (observes only)
 * - Does not allow modification of historical observations
 * - Does not provide access to internal state outside of authorized channels
 */

use serde::{Deserialize, Serialize};
use blake3;

/// Observation event generated by the world
/// 
/// Represents an observable change in the world state that
/// can be used for debugging, auditing, or agent notifications.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ObservationEvent {
    /// The tick at which this observation was generated
    pub tick: u64,
    /// Type of observation event
    /// Examples: "agent_moved", "state_changed", "action_resolved"
    pub event_type: String,
    /// JSON payload with detailed observation data
    /// Contains state differences or event-specific information
    pub payload: serde_json::Value,
    /// Hash of this observation for verification
    pub hash: [u8; 32],
}

impl ObservationEvent {
    /// Creates ObservationEvent from state transition with deterministic hashing
    /// 
    /// This is the authoritative method for creating observation events.
    /// It captures the exact state change caused by an InputEvent.
    pub fn from_transition(tick: u64, input_event: &super::InputEvent, before_state: &[u8], after_state: &[u8]) -> Self {
        let event_type = match &input_event.payload {
            super::InputEventPayload::Move { .. } => "agent_moved",
            super::InputEventPayload::Chat { .. } => "chat",
            super::InputEventPayload::Gather { .. } => "gather",
            super::InputEventPayload::Craft { .. } => "craft",
            super::InputEventPayload::Mine => "mine",
            super::InputEventPayload::Build { .. } => "build",
            // Phase 0 required events
            super::InputEventPayload::BootEvent => "boot_event",
            super::InputEventPayload::TickAdvance => "tick_advance",
            super::InputEventPayload::InputEventSubmitted => "input_event_submitted",
            super::InputEventPayload::ObservationEvent => "observation_event",
            super::InputEventPayload::SnapshotTaken => "snapshot_taken",
        }.to_string();

        // Create deterministic state diff payload
        let payload = serde_json::json!({
            "input_event_hash": hex::encode(input_event.hash),
            "input_event_tick": input_event.tick,
            "input_event_sequence": input_event.sequence,
            "before_state_hash": hex::encode(blake3::hash(before_state).as_bytes()),
            "after_state_hash": hex::encode(blake3::hash(after_state).as_bytes()),
            "state_size_change": after_state.len() as i64 - before_state.len() as i64
        });

        let mut event = Self {
            tick,
            event_type,
            payload,
            hash: [0u8; 32], // Will be computed
        };

        // Compute deterministic hash of the observation
        event.hash = event.compute_hash();
        event
    }

    /// Computes deterministic hash for this ObservationEvent
    /// 
    /// Hash includes all observation data to ensure immutability.
    /// Any modification to observation data will be detectable.
    fn compute_hash(&self) -> [u8; 32] {
        let mut hasher = blake3::Hasher::new();
        
        // Hash tick and event type
        let _ = hasher.update(&self.tick.to_le_bytes());
        let _ = hasher.update(self.event_type.as_bytes());
        
        // Hash payload using canonical serialization
        let payload_bytes = serde_json::to_vec(&self.payload)
            .expect("Failed to serialize ObservationEvent payload for hashing");
        let _ = hasher.update(&payload_bytes);
        
        hasher.finalize().into()
    }
    
    /// Verifies that this observation correctly represents the state transition
    /// 
    /// This method validates that the observation's hash matches
    /// the computed hash from its data, ensuring no tampering occurred.
    pub fn verify_integrity(&self) -> bool {
        self.hash == self.compute_hash()
    }
    
    /// Creates a system-generated observation (not from InputEvent)
    /// 
    /// Used for system-level events like boot, tick advancement, etc.
    pub fn system_event(tick: u64, event_type: &str, payload: serde_json::Value) -> Self {
        let mut event = Self {
            tick,
            event_type: event_type.to_string(),
            payload,
            hash: [0u8; 32], // Will be computed
        };
        
        event.hash = event.compute_hash();
        event
    }
}
