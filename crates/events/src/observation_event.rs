/*!
 * File: crates/events/src/observation_event.rs
 * 
 * Purpose: Defines ObservationEvent schema for Phase 0 deterministic state change tracking
 * 
 * Why this file exists:
 * - Provides immutable observation records for all state transitions
 * - Enables hash-based verification of world state integrity
 * - Supports deterministic replay by logging exact state changes
 * - Implements audit trail for all InputEvent processing
 * 
 * Phase plan authority: PLAN_PHASE_0_BOOTSTRAP.md
 * Section 4 "OBSERVATION EVENT SCHEMA"
 * 
 * Invariants enforced:
 * - All observations are immutable once created
 * - Hash verification ensures no tampering occurred
 * - State changes are logged with before/after hashes
 * - Observations are ordered by tick for replay
 * 
 * What breaks if removed:
 * - No observation trail → cannot verify state integrity
 * - No hash verification → undetectable tampering
 * - No before/after state → cannot replay deterministically
 * - No audit trail → cannot debug divergences
 * 
 * What this file does NOT do:
 * - Does not implement state mutation logic (observes only)
 * - Does not allow modification of historical observations
 * - Does not provide access to internal state outside of authorized channels
 */

use serde::{Deserialize, Serialize};
use blake3;

/// Observation event generated by the world
/// 
/// Represents an observable change in the world state that
/// can be used for debugging, auditing, or agent notifications.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ObservationEvent {
    /// The tick at which this observation was generated
    pub tick: u64,
    /// Type of observation event
    /// Examples: "agent_moved", "state_changed", "action_resolved"
    pub event_type: String,
    /// JSON payload with detailed observation data
    /// Contains state differences or event-specific information
    pub payload: serde_json::Value,
    /// Hash of this observation for verification
    pub hash: [u8; 32],
}

impl ObservationEvent {
    /// Creates ObservationEvent from state transition with deterministic hashing
    /// 
    /// This is the authoritative method for creating observation events.
    /// It captures the exact state change caused by an InputEvent.
    pub fn from_transition(tick: u64, input_event: &super::InputEvent, before_state: &[u8], after_state: &[u8]) -> Result<Self, String> {
        let event_type = match &input_event.payload {
            super::InputEventPayload::Move { .. } => "agent_moved",
            super::InputEventPayload::Chat { .. } => "chat",
            super::InputEventPayload::Gather { .. } => "gather",
            super::InputEventPayload::Craft { .. } => "craft",
            super::InputEventPayload::Mine => "mine",
            super::InputEventPayload::Build { .. } => "build",
            // Phase 0 required events
            super::InputEventPayload::BootEvent => "boot_event",
            super::InputEventPayload::TickAdvance => "tick_advance",
            super::InputEventPayload::InputEventSubmitted => "input_event_submitted",
            super::InputEventPayload::ObservationEvent => "observation_event",
            super::InputEventPayload::SnapshotTaken => "snapshot_taken",
        }.to_string();

        // Create deterministic state diff payload
        let payload = serde_json::json!({
            "input_event_hash": hex::encode(input_event.hash),
            "input_event_tick": input_event.tick,
            "input_event_sequence": input_event.sequence,
            "before_state_hash": hex::encode(blake3::hash(before_state).as_bytes()),
            "after_state_hash": hex::encode(blake3::hash(after_state).as_bytes()),
            "state_size_change": after_state.len() as i64 - before_state.len() as i64
        });

        let mut event = Self {
            tick,
            event_type,
            payload,
            hash: [0u8; 32], // Will be computed
        };

        // Compute deterministic hash of the observation
        event.hash = event.compute_hash().map_err(|_| "Failed to compute observation hash")?;
        Ok(event)
    }

    /// Computes deterministic hash for this ObservationEvent
    /// 
    /// Hash includes all observation data to ensure immutability.
    /// Any modification to observation data will be detectable.
    fn compute_hash(&self) -> Result<[u8; 32], String> {
        let mut hasher = blake3::Hasher::new();
        
        // Hash tick and event type
        let _ = hasher.update(&self.tick.to_le_bytes());
        let _ = hasher.update(self.event_type.as_bytes());
        
        // Hash payload using canonical serialization
        let payload_bytes = serde_json::to_vec(&self.payload)
            .map_err(|_| "Failed to serialize ObservationEvent payload for hashing")?;
        let _ = hasher.update(&payload_bytes);
        
        Ok(hasher.finalize().into())
    }
    
    /// Verifies that this observation correctly represents the state transition
    /// 
    /// This method validates that the observation's hash matches
    /// the computed hash from its data, ensuring no tampering occurred.
    pub fn verify_integrity(&self) -> bool {
        self.compute_hash() == Ok(self.hash)
    }
    
    /// Creates a system-generated observation (not from InputEvent)
    /// 
    /// Used for system-level events like boot, tick advancement, etc.
    pub fn system_event(tick: u64, event_type: &str, payload: serde_json::Value) -> Self {
        let mut event = Self {
            tick,
            event_type: event_type.to_string(),
            payload,
            hash: [0u8; 32], // Will be computed
        };
        
        // Compute deterministic hash - system events are infallible
        event.hash = event.compute_hash().unwrap_or([0u8; 32]);
        event
    }
}
