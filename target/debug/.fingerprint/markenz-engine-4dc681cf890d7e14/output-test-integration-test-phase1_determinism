{"$message_type":"diagnostic","message":"missing documentation for the crate","code":{"code":"missing_docs","explanation":null},"level":"warning","spans":[{"file_name":"apps/engine/../../tests/phase1_determinism.rs","byte_start":0,"byte_end":14433,"line_start":1,"line_end":372,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"/**","highlight_start":1,"highlight_end":4},{"text":" * File: tests/phase1_determinism.rs","highlight_start":1,"highlight_end":37},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Purpose: Phase 1 determinism validation tests","highlight_start":1,"highlight_end":49},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Why this file exists:","highlight_start":1,"highlight_end":25},{"text":" * - Implements TEST-DET-001: Fixed Seed Reproducibility","highlight_start":1,"highlight_end":57},{"text":" * - Implements TEST-SNAPSHOT-EQ-001: Snapshot Replay Equivalence  ","highlight_start":1,"highlight_end":68},{"text":" * - Implements TEST-HASH-CHAIN-001: Hash Chain Integrity","highlight_start":1,"highlight_end":58},{"text":" * - Implements TEST-RNG-001: RNG Chaos Stability","highlight_start":1,"highlight_end":50},{"text":" * - Validates Phase 1 determinism guarantees per PLAN_PHASE_1_DETERMINISM.md","highlight_start":1,"highlight_end":78},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Phase plan authority: docs/plans/PLAN_PHASE_1_DETERMINISM.md","highlight_start":1,"highlight_end":64},{"text":" * Section 6 \"REPLAY HARNESS\", Section 8 \"SUCCESS CRITERIA\"","highlight_start":1,"highlight_end":60},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Invariants enforced:","highlight_start":1,"highlight_end":24},{"text":" * - Same seed + same events = identical hash sequences across runs","highlight_start":1,"highlight_end":68},{"text":" * - Snapshot replay = full replay from same tick onward","highlight_start":1,"highlight_end":57},{"text":" * - Hash chain continuity must be maintained without breaks","highlight_start":1,"highlight_end":61},{"text":" * - RNG values must be stable and reproducible across platforms","highlight_start":1,"highlight_end":65},{"text":" * - All RNG draws must be audit-logged","highlight_start":1,"highlight_end":40},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * What breaks if removed:","highlight_start":1,"highlight_end":27},{"text":" * - No determinism validation → Phase 1 requirements unverified","highlight_start":1,"highlight_end":65},{"text":" * - No snapshot testing → replay equivalence unproven","highlight_start":1,"highlight_end":55},{"text":" * - No hash chain testing → corruption detection missing","highlight_start":1,"highlight_end":58},{"text":" * - No RNG testing → platform independence unverified","highlight_start":1,"highlight_end":55},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * What this file does NOT do:","highlight_start":1,"highlight_end":31},{"text":" * - Does not test Phase 2+ features (biology, cognition, etc.)","highlight_start":1,"highlight_end":64},{"text":" * - Does not permit any nondeterministic behavior in tests","highlight_start":1,"highlight_end":60},{"text":" * - Does not allow test fixtures to be platform-dependent","highlight_start":1,"highlight_end":59},{"text":" */","highlight_start":1,"highlight_end":4},{"text":"","highlight_start":1,"highlight_end":1},{"text":"use std::collections::BTreeMap;","highlight_start":1,"highlight_end":32},{"text":"use markenz_engine::deterministic_world_loop::{DeterministicWorldLoop, DeterministicWorldConfig};","highlight_start":1,"highlight_end":98},{"text":"use markenz_events::{InputEvent, InputEventPayload};","highlight_start":1,"highlight_end":53},{"text":"use rng::rng_stream::RngSubsystem;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// TEST-DET-001: Fixed Seed Reproducibility","highlight_start":1,"highlight_end":45},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// Requirement: Same seed + same ordered InputEvents ⇒ identical hash sequence","highlight_start":1,"highlight_end":80},{"text":"/// Three identical runs must produce bit-for-bit identical hash sequences","highlight_start":1,"highlight_end":75},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_determinism_fixed_seed() -> Result<(), String> {","highlight_start":1,"highlight_end":57},{"text":"    let seed = 12345u64;","highlight_start":1,"highlight_end":25},{"text":"    let num_ticks = 100;","highlight_start":1,"highlight_end":25},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Create identical input events for all runs","highlight_start":1,"highlight_end":50},{"text":"    let mut input_events = BTreeMap::new();","highlight_start":1,"highlight_end":44},{"text":"    input_events.insert(5, vec![","highlight_start":1,"highlight_end":33},{"text":"        InputEvent {","highlight_start":1,"highlight_end":21},{"text":"            tick: 5,","highlight_start":1,"highlight_end":21},{"text":"            source_agent_id: 1,","highlight_start":1,"highlight_end":32},{"text":"            sequence: 1,","highlight_start":1,"highlight_end":25},{"text":"            payload: InputEventPayload::Move { x: 10.0, y: 20.0, z: 0.0 },","highlight_start":1,"highlight_end":75},{"text":"            hash: [0u8; 32],","highlight_start":1,"highlight_end":29},{"text":"            prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ]);","highlight_start":1,"highlight_end":8},{"text":"    input_events.insert(10, vec![","highlight_start":1,"highlight_end":34},{"text":"        InputEvent {","highlight_start":1,"highlight_end":21},{"text":"            tick: 10,","highlight_start":1,"highlight_end":22},{"text":"            source_agent_id: 2,","highlight_start":1,"highlight_end":32},{"text":"            sequence: 1,","highlight_start":1,"highlight_end":25},{"text":"            payload: InputEventPayload::Move { x: -5.0, y: 15.0, z: 2.0 },","highlight_start":1,"highlight_end":75},{"text":"            hash: [0u8; 32],","highlight_start":1,"highlight_end":29},{"text":"            prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ]);","highlight_start":1,"highlight_end":8},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let config = DeterministicWorldConfig {","highlight_start":1,"highlight_end":44},{"text":"        genesis_seed: seed,","highlight_start":1,"highlight_end":28},{"text":"        max_ticks: num_ticks,","highlight_start":1,"highlight_end":30},{"text":"        snapshot_interval: 50,","highlight_start":1,"highlight_end":31},{"text":"        tick_rate_ms: 50,","highlight_start":1,"highlight_end":26},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run 1","highlight_start":1,"highlight_end":13},{"text":"    let mut world_loop1 = DeterministicWorldLoop::new(config.clone());","highlight_start":1,"highlight_end":71},{"text":"    world_loop1.run(input_events.clone()).map_err(|e| format!(\"Run 1 failed: {}\", e))?;","highlight_start":1,"highlight_end":88},{"text":"    let hashes1 = world_loop1.hash_chain().to_vec();","highlight_start":1,"highlight_end":53},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run 2","highlight_start":1,"highlight_end":13},{"text":"    let mut world_loop2 = DeterministicWorldLoop::new(config.clone());","highlight_start":1,"highlight_end":71},{"text":"    world_loop2.run(input_events.clone()).map_err(|e| format!(\"Run 2 failed: {}\", e))?;","highlight_start":1,"highlight_end":88},{"text":"    let hashes2 = world_loop2.hash_chain().to_vec();","highlight_start":1,"highlight_end":53},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run 3","highlight_start":1,"highlight_end":13},{"text":"    let mut world_loop3 = DeterministicWorldLoop::new(config);","highlight_start":1,"highlight_end":63},{"text":"    world_loop3.run(input_events).map_err(|e| format!(\"Run 3 failed: {}\", e))?;","highlight_start":1,"highlight_end":80},{"text":"    let hashes3 = world_loop3.hash_chain().to_vec();","highlight_start":1,"highlight_end":53},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // All three runs must produce identical hashes","highlight_start":1,"highlight_end":52},{"text":"    assert_eq!(hashes1.len(), hashes2.len(), \"Hash sequence length mismatch between run 1 and 2\");","highlight_start":1,"highlight_end":99},{"text":"    assert_eq!(hashes2.len(), hashes3.len(), \"Hash sequence length mismatch between run 2 and 3\");","highlight_start":1,"highlight_end":99},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    for (i, (h1, h2)) in hashes1.iter().zip(hashes2.iter()).enumerate() {","highlight_start":1,"highlight_end":74},{"text":"        assert_eq!(h1, h2, \"Hashes differ at tick {} between run 1 and 2: {:x?} vs {:x?}\", i, h1, h2);","highlight_start":1,"highlight_end":103},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    for (i, (h2, h3)) in hashes2.iter().zip(hashes3.iter()).enumerate() {","highlight_start":1,"highlight_end":74},{"text":"        assert_eq!(h2, h3, \"Hashes differ at tick {} between run 2 and 3: {:x?} vs {:x?}\", i, h2, h3);","highlight_start":1,"highlight_end":103},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ TEST-DET-001 PASSED: All {} hashes identical across 3 runs\", hashes1.len());","highlight_start":1,"highlight_end":93},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// TEST-SNAPSHOT-EQ-001: Snapshot Replay Equivalence","highlight_start":1,"highlight_end":54},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// Requirement: Load snapshot at tick T; replay events from T onward = full replay from boot","highlight_start":1,"highlight_end":94},{"text":"/// Hashes from snapshot replay must match full replay from same tick onward","highlight_start":1,"highlight_end":77},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_snapshot_replay_equivalence() -> Result<(), String> {","highlight_start":1,"highlight_end":62},{"text":"    let seed = 12345u64;","highlight_start":1,"highlight_end":25},{"text":"    let total_ticks = 200;","highlight_start":1,"highlight_end":27},{"text":"    let snapshot_tick = 100;","highlight_start":1,"highlight_end":29},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Create input events spanning the full run","highlight_start":1,"highlight_end":49},{"text":"    let mut input_events = BTreeMap::new();","highlight_start":1,"highlight_end":44},{"text":"    for tick in [20, 50, 80, 120, 150, 180] {","highlight_start":1,"highlight_end":46},{"text":"        input_events.insert(tick, vec![","highlight_start":1,"highlight_end":40},{"text":"            InputEvent {","highlight_start":1,"highlight_end":25},{"text":"                tick,","highlight_start":1,"highlight_end":22},{"text":"                source_agent_id: 1,","highlight_start":1,"highlight_end":36},{"text":"                sequence: 1,","highlight_start":1,"highlight_end":29},{"text":"                payload: InputEventPayload::Move { ","highlight_start":1,"highlight_end":52},{"text":"                    x: tick as f32, ","highlight_start":1,"highlight_end":37},{"text":"                    y: (tick * 2) as f32, ","highlight_start":1,"highlight_end":43},{"text":"                    z: 0.0 ","highlight_start":1,"highlight_end":28},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                hash: [0u8; 32],","highlight_start":1,"highlight_end":33},{"text":"                prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        ]);","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Full run: ticks 0-200","highlight_start":1,"highlight_end":29},{"text":"    let mut full_loop = DeterministicWorldLoop::new(DeterministicWorldConfig {","highlight_start":1,"highlight_end":79},{"text":"        genesis_seed: seed,","highlight_start":1,"highlight_end":28},{"text":"        max_ticks: total_ticks,","highlight_start":1,"highlight_end":32},{"text":"        snapshot_interval: 1000, // No automatic snapshots","highlight_start":1,"highlight_end":59},{"text":"        tick_rate_ms: 50,","highlight_start":1,"highlight_end":26},{"text":"    });","highlight_start":1,"highlight_end":8},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    full_loop.run(input_events.clone()).map_err(|e| format!(\"Full run failed: {}\", e))?;","highlight_start":1,"highlight_end":89},{"text":"    let full_hashes = full_loop.hash_chain().to_vec();","highlight_start":1,"highlight_end":55},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Snapshot run: run to snapshot_tick, then continue to total_ticks","highlight_start":1,"highlight_end":72},{"text":"    let mut snapshot_loop = DeterministicWorldLoop::new(DeterministicWorldConfig {","highlight_start":1,"highlight_end":83},{"text":"        genesis_seed: seed,","highlight_start":1,"highlight_end":28},{"text":"        max_ticks: snapshot_tick,","highlight_start":1,"highlight_end":34},{"text":"        snapshot_interval: 1000,","highlight_start":1,"highlight_end":33},{"text":"        tick_rate_ms: 50,","highlight_start":1,"highlight_end":26},{"text":"    });","highlight_start":1,"highlight_end":8},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run to snapshot point","highlight_start":1,"highlight_end":29},{"text":"    let snapshot_events: BTreeMap<u64, Vec<InputEvent>> = input_events","highlight_start":1,"highlight_end":71},{"text":"        .iter()","highlight_start":1,"highlight_end":16},{"text":"        .filter(|(&tick, _)| tick <= snapshot_tick)","highlight_start":1,"highlight_end":52},{"text":"        .map(|(&tick, events)| (tick, events.clone()))","highlight_start":1,"highlight_end":55},{"text":"        .collect();","highlight_start":1,"highlight_end":20},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    snapshot_loop.run(snapshot_events).map_err(|e| format!(\"Snapshot run to tick {} failed: {}\", snapshot_tick, e))?;","highlight_start":1,"highlight_end":118},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Continue from snapshot point","highlight_start":1,"highlight_end":36},{"text":"    snapshot_loop.config.max_ticks = total_ticks;","highlight_start":1,"highlight_end":50},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let remaining_events: BTreeMap<u64, Vec<InputEvent>> = input_events","highlight_start":1,"highlight_end":72},{"text":"        .iter()","highlight_start":1,"highlight_end":16},{"text":"        .filter(|(&tick, _)| tick > snapshot_tick)","highlight_start":1,"highlight_end":51},{"text":"        .map(|(&tick, events)| (tick, events.clone()))","highlight_start":1,"highlight_end":55},{"text":"        .collect();","highlight_start":1,"highlight_end":20},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    snapshot_loop.run(remaining_events).map_err(|e| format!(\"Snapshot continuation failed: {}\", e))?;","highlight_start":1,"highlight_end":102},{"text":"    let snapshot_hashes = snapshot_loop.hash_chain().to_vec();","highlight_start":1,"highlight_end":63},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Hashes from tick 100-200 must match exactly","highlight_start":1,"highlight_end":51},{"text":"    let full_tail = &full_hashes[snapshot_tick as usize..total_ticks as usize];","highlight_start":1,"highlight_end":80},{"text":"    let snap_tail = &snapshot_hashes[snapshot_tick as usize..total_ticks as usize];","highlight_start":1,"highlight_end":84},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    assert_eq!(full_tail.len(), snap_tail.len(), \"Tail length mismatch\");","highlight_start":1,"highlight_end":74},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    for (i, (full_hash, snap_hash)) in full_tail.iter().zip(snap_tail.iter()).enumerate() {","highlight_start":1,"highlight_end":92},{"text":"        let tick = snapshot_tick + i as u64;","highlight_start":1,"highlight_end":45},{"text":"        assert_eq!(full_hash, snap_hash, ","highlight_start":1,"highlight_end":42},{"text":"            \"Hash mismatch at tick {}: full={:x?}, snapshot={:x?}\", ","highlight_start":1,"highlight_end":69},{"text":"            tick, full_hash, snap_hash);","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ TEST-SNAPSHOT-EQ-001 PASSED: {} hashes match from tick {} to {}\", ","highlight_start":1,"highlight_end":83},{"text":"        full_tail.len(), snapshot_tick, total_ticks);","highlight_start":1,"highlight_end":54},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// TEST-HASH-CHAIN-001: Hash Chain Integrity","highlight_start":1,"highlight_end":46},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// Requirement: Hash chain must be continuous with no breaks","highlight_start":1,"highlight_end":62},{"text":"/// Each hash must be computed from the previous state deterministically","highlight_start":1,"highlight_end":73},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_hash_chain_integrity() -> Result<(), String> {","highlight_start":1,"highlight_end":55},{"text":"    let seed = 54321u64;","highlight_start":1,"highlight_end":25},{"text":"    let num_ticks = 50;","highlight_start":1,"highlight_end":24},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let mut world_loop = DeterministicWorldLoop::new(DeterministicWorldConfig {","highlight_start":1,"highlight_end":80},{"text":"        genesis_seed: seed,","highlight_start":1,"highlight_end":28},{"text":"        max_ticks: num_ticks,","highlight_start":1,"highlight_end":30},{"text":"        snapshot_interval: 1000, // No automatic snapshots","highlight_start":1,"highlight_end":59},{"text":"        tick_rate_ms: 50,","highlight_start":1,"highlight_end":26},{"text":"    });","highlight_start":1,"highlight_end":8},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run with no input events (pure determinism test)","highlight_start":1,"highlight_end":56},{"text":"    let empty_events = BTreeMap::new();","highlight_start":1,"highlight_end":40},{"text":"    world_loop.run(empty_events).map_err(|e| format!(\"Hash chain test run failed: {}\", e))?;","highlight_start":1,"highlight_end":93},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let hash_chain = world_loop.hash_chain();","highlight_start":1,"highlight_end":46},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify hash chain properties","highlight_start":1,"highlight_end":36},{"text":"    assert_eq!(hash_chain.len(), num_ticks as usize + 1, ","highlight_start":1,"highlight_end":58},{"text":"        \"Hash chain should have genesis + {} hashes\", num_ticks);","highlight_start":1,"highlight_end":66},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify no zero hashes (except possibly genesis)","highlight_start":1,"highlight_end":55},{"text":"    for (i, hash) in hash_chain.iter().enumerate() {","highlight_start":1,"highlight_end":53},{"text":"        if i > 0 { // Skip genesis hash check","highlight_start":1,"highlight_end":46},{"text":"            assert_ne!(hash, &[0u8; 32], \"Hash at position {} cannot be zero\", i);","highlight_start":1,"highlight_end":83},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify hash uniqueness (no duplicate consecutive hashes)","highlight_start":1,"highlight_end":64},{"text":"    for i in 1..hash_chain.len() {","highlight_start":1,"highlight_end":35},{"text":"        assert_ne!(hash_chain[i-1], hash_chain[i], ","highlight_start":1,"highlight_end":52},{"text":"            \"Consecutive hashes at positions {} and {} cannot be identical\", ","highlight_start":1,"highlight_end":78},{"text":"            i-1, i);","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ TEST-HASH-CHAIN-001 PASSED: {} unique hashes in chain\", hash_chain.len());","highlight_start":1,"highlight_end":91},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// TEST-RNG-001: RNG Chaos Stability","highlight_start":1,"highlight_end":38},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// Requirement: RNG must produce stable, reproducible sequences","highlight_start":1,"highlight_end":65},{"text":"/// Same seed must produce identical values across runs","highlight_start":1,"highlight_end":56},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_rng_chaos_stability() -> Result<(), String> {","highlight_start":1,"highlight_end":54},{"text":"    let seed = 999u64;","highlight_start":1,"highlight_end":23},{"text":"    let num_draws = 1000;","highlight_start":1,"highlight_end":26},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Create two identical RNG instances","highlight_start":1,"highlight_end":42},{"text":"    let mut rng1 = rng::DeterministicRng::new(seed);","highlight_start":1,"highlight_end":53},{"text":"    let mut rng2 = rng::DeterministicRng::new(seed);","highlight_start":1,"highlight_end":53},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Generate sequence from first RNG","highlight_start":1,"highlight_end":40},{"text":"    let mut values1 = Vec::new();","highlight_start":1,"highlight_end":34},{"text":"    for tick in 1..=num_draws {","highlight_start":1,"highlight_end":32},{"text":"        rng1.set_tick(tick);","highlight_start":1,"highlight_end":29},{"text":"        let mut stream = rng1.stream(RngSubsystem::Physics, 0);","highlight_start":1,"highlight_end":64},{"text":"        let value = stream.next_u64(\"test_rng_chaos_stability.rs:value\");","highlight_start":1,"highlight_end":74},{"text":"        values1.push(value);","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Generate sequence from second RNG","highlight_start":1,"highlight_end":41},{"text":"    let mut values2 = Vec::new();","highlight_start":1,"highlight_end":34},{"text":"    for tick in 1..=num_draws {","highlight_start":1,"highlight_end":32},{"text":"        rng2.set_tick(tick);","highlight_start":1,"highlight_end":29},{"text":"        let mut stream = rng2.stream(RngSubsystem::Physics, 0);","highlight_start":1,"highlight_end":64},{"text":"        let value = stream.next_u64(\"test_rng_chaos_stability.rs:value\");","highlight_start":1,"highlight_end":74},{"text":"        values2.push(value);","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify sequences are identical","highlight_start":1,"highlight_end":38},{"text":"    assert_eq!(values1.len(), values2.len(), \"Sequence length mismatch\");","highlight_start":1,"highlight_end":74},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    for (i, (v1, v2)) in values1.iter().zip(values2.iter()).enumerate() {","highlight_start":1,"highlight_end":74},{"text":"        assert_eq!(v1, v2, \"RNG values differ at draw {}: {} vs {}\", i, v1, v2);","highlight_start":1,"highlight_end":81},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify RNG audit logging","highlight_start":1,"highlight_end":32},{"text":"    let audit_log = rng1.audit_log();","highlight_start":1,"highlight_end":38},{"text":"    assert_eq!(audit_log.len(), num_draws as usize, \"Audit log should contain {} entries\", num_draws);","highlight_start":1,"highlight_end":103},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify audit log entries are correct","highlight_start":1,"highlight_end":44},{"text":"    for (i, record) in audit_log.records().iter().enumerate() {","highlight_start":1,"highlight_end":64},{"text":"        assert_eq!(record.tick, (i + 1) as u64, \"Record {} has wrong tick\", i);","highlight_start":1,"highlight_end":80},{"text":"        assert_eq!(record.subsystem, RngSubsystem::Physics, \"Record {} has wrong subsystem\", i);","highlight_start":1,"highlight_end":97},{"text":"        assert_eq!(record.stream_id, 0, \"Record {} has wrong stream ID\", i);","highlight_start":1,"highlight_end":77},{"text":"        assert_eq!(record.value, values1[i], \"Record {} has wrong value\", i);","highlight_start":1,"highlight_end":78},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ TEST-RNG-001 PASSED: {} identical RNG values with full audit logging\", num_draws);","highlight_start":1,"highlight_end":99},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// TEST-RNG-AUDIT-001: RNG Sequence Bit-Identical Across Platforms","highlight_start":1,"highlight_end":68},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// Requirement: Platform-independent RNG behavior","highlight_start":1,"highlight_end":51},{"text":"/// Same seed must produce identical sequences on all platforms","highlight_start":1,"highlight_end":64},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_rng_platform_independence() -> Result<(), String> {","highlight_start":1,"highlight_end":60},{"text":"    let seed = 42u64;","highlight_start":1,"highlight_end":22},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Create RNG with known seed","highlight_start":1,"highlight_end":34},{"text":"    let mut rng = rng::DeterministicRng::new(seed);","highlight_start":1,"highlight_end":52},{"text":"    rng.set_tick(1);","highlight_start":1,"highlight_end":21},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Generate test sequence from multiple subsystems","highlight_start":1,"highlight_end":55},{"text":"    let mut physics_values = Vec::new();","highlight_start":1,"highlight_end":41},{"text":"    let mut biology_values = Vec::new();","highlight_start":1,"highlight_end":41},{"text":"    let mut cognition_values = Vec::new();","highlight_start":1,"highlight_end":43},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    for i in 0..100 {","highlight_start":1,"highlight_end":22},{"text":"        rng.set_tick(i + 1);","highlight_start":1,"highlight_end":29},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        // Physics stream","highlight_start":1,"highlight_end":26},{"text":"        let mut physics_stream = rng.stream(RngSubsystem::Physics, 0);","highlight_start":1,"highlight_end":71},{"text":"        physics_values.push(physics_stream.next_u64(\"test_rng_platform_independence.rs:physics\"));","highlight_start":1,"highlight_end":99},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        // Biology stream  ","highlight_start":1,"highlight_end":28},{"text":"        let mut biology_stream = rng.stream(RngSubsystem::Biology, 0);","highlight_start":1,"highlight_end":71},{"text":"        biology_values.push(biology_stream.next_u64(\"test_rng_platform_independence.rs:biology\"));","highlight_start":1,"highlight_end":99},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        // Cognition stream","highlight_start":1,"highlight_end":28},{"text":"        let mut cognition_stream = rng.stream(RngSubsystem::Cognition, 0);","highlight_start":1,"highlight_end":75},{"text":"        cognition_values.push(cognition_stream.next_u64(\"test_rng_platform_independence.rs:cognition\"));","highlight_start":1,"highlight_end":105},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify subsystem isolation (different streams should produce different values)","highlight_start":1,"highlight_end":86},{"text":"    assert_ne!(physics_values, biology_values, \"Physics and Biology streams must differ\");","highlight_start":1,"highlight_end":91},{"text":"    assert_ne!(biology_values, cognition_values, \"Biology and Cognition streams must differ\");","highlight_start":1,"highlight_end":95},{"text":"    assert_ne!(physics_values, cognition_values, \"Physics and Cognition streams must differ\");","highlight_start":1,"highlight_end":95},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify audit log contains all draws","highlight_start":1,"highlight_end":43},{"text":"    let audit_log = rng.audit_log();","highlight_start":1,"highlight_end":37},{"text":"    assert_eq!(audit_log.len(), 300, \"Should have 300 audit entries (100 per subsystem)\");","highlight_start":1,"highlight_end":91},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify subsystem distribution in audit log","highlight_start":1,"highlight_end":50},{"text":"    let physics_records = audit_log.records_by_subsystem(RngSubsystem::Physics);","highlight_start":1,"highlight_end":81},{"text":"    let biology_records = audit_log.records_by_subsystem(RngSubsystem::Biology);","highlight_start":1,"highlight_end":81},{"text":"    let cognition_records = audit_log.records_by_subsystem(RngSubsystem::Cognition);","highlight_start":1,"highlight_end":85},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    assert_eq!(physics_records.len(), 100, \"Should have 100 physics records\");","highlight_start":1,"highlight_end":79},{"text":"    assert_eq!(biology_records.len(), 100, \"Should have 100 biology records\");","highlight_start":1,"highlight_end":79},{"text":"    assert_eq!(cognition_records.len(), 100, \"Should have 100 cognition records\");","highlight_start":1,"highlight_end":83},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ TEST-RNG-AUDIT-001 PASSED: Platform-independent RNG with {} audit entries\", audit_log.len());","highlight_start":1,"highlight_end":110},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Integration test combining all Phase 1 determinism requirements","highlight_start":1,"highlight_end":68},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_phase1_determinism_integration() -> Result<(), String> {","highlight_start":1,"highlight_end":65},{"text":"    println!(\"Running Phase 1 Determinism Integration Test...\");","highlight_start":1,"highlight_end":65},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Run all individual tests","highlight_start":1,"highlight_end":32},{"text":"    test_determinism_fixed_seed()?;","highlight_start":1,"highlight_end":36},{"text":"    test_snapshot_replay_equivalence()?;","highlight_start":1,"highlight_end":41},{"text":"    test_hash_chain_integrity()?;","highlight_start":1,"highlight_end":34},{"text":"    test_rng_chaos_stability()?;","highlight_start":1,"highlight_end":33},{"text":"    test_rng_platform_independence()?;","highlight_start":1,"highlight_end":39},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✅ PHASE 1 DETERMINISM INTEGRATION TEST PASSED\");","highlight_start":1,"highlight_end":63},{"text":"    println!(\"All Phase 1 determinism guarantees verified:\");","highlight_start":1,"highlight_end":62},{"text":"    println!(\"  - Fixed seed reproducibility ✓\");","highlight_start":1,"highlight_end":50},{"text":"    println!(\"  - Snapshot replay equivalence ✓\");","highlight_start":1,"highlight_end":51},{"text":"    println!(\"  - Hash chain integrity ✓\");","highlight_start":1,"highlight_end":44},{"text":"    println!(\"  - RNG chaos stability ✓\");","highlight_start":1,"highlight_end":43},{"text":"    println!(\"  - Platform independence ✓\");","highlight_start":1,"highlight_end":45},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    Ok(())","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"requested on the command line with `-W missing-docs`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: missing documentation for the crate\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mapps/engine/../../tests/phase1_determinism.rs:1:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m/\u001b[0m /**\n  \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * File: tests/phase1_determinism.rs\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * \n  \u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * Purpose: Phase 1 determinism validation tests\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[33m|\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m     Ok(())\n\u001b[1m\u001b[94m372\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|_^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: requested on the command line with `-W missing-docs`\n\n"}
{"$message_type":"diagnostic","message":"unused result of type `Option<Vec<InputEvent>>`","code":{"code":"unused_results","explanation":null},"level":"error","spans":[{"file_name":"apps/engine/../../tests/phase1_determinism.rs","byte_start":2020,"byte_end":2303,"line_start":51,"line_end":60,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    input_events.insert(5, vec![","highlight_start":5,"highlight_end":33},{"text":"        InputEvent {","highlight_start":1,"highlight_end":21},{"text":"            tick: 5,","highlight_start":1,"highlight_end":21},{"text":"            source_agent_id: 1,","highlight_start":1,"highlight_end":32},{"text":"            sequence: 1,","highlight_start":1,"highlight_end":25},{"text":"            payload: InputEventPayload::Move { x: 10.0, y: 20.0, z: 0.0 },","highlight_start":1,"highlight_end":75},{"text":"            hash: [0u8; 32],","highlight_start":1,"highlight_end":29},{"text":"            prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ]);","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"requested on the command line with `-D unused-results`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: unused result of type `Option<Vec<InputEvent>>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mapps/engine/../../tests/phase1_determinism.rs:51:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     input_events.insert(5, vec![\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         InputEvent {\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             tick: 5,\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             source_agent_id: 1,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     ]);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_______^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: requested on the command line with `-D unused-results`\n\n"}
{"$message_type":"diagnostic","message":"unused result of type `Option<Vec<InputEvent>>`","code":{"code":"unused_results","explanation":null},"level":"error","spans":[{"file_name":"apps/engine/../../tests/phase1_determinism.rs","byte_start":2308,"byte_end":2593,"line_start":61,"line_end":70,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    input_events.insert(10, vec![","highlight_start":5,"highlight_end":34},{"text":"        InputEvent {","highlight_start":1,"highlight_end":21},{"text":"            tick: 10,","highlight_start":1,"highlight_end":22},{"text":"            source_agent_id: 2,","highlight_start":1,"highlight_end":32},{"text":"            sequence: 1,","highlight_start":1,"highlight_end":25},{"text":"            payload: InputEventPayload::Move { x: -5.0, y: 15.0, z: 2.0 },","highlight_start":1,"highlight_end":75},{"text":"            hash: [0u8; 32],","highlight_start":1,"highlight_end":29},{"text":"            prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ]);","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: unused result of type `Option<Vec<InputEvent>>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mapps/engine/../../tests/phase1_determinism.rs:61:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     input_events.insert(10, vec![\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         InputEvent {\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             tick: 10,\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             source_agent_id: 2,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     ]);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_______^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused result of type `Option<Vec<InputEvent>>`","code":{"code":"unused_results","explanation":null},"level":"error","spans":[{"file_name":"apps/engine/../../tests/phase1_determinism.rs","byte_start":4717,"byte_end":5136,"line_start":123,"line_end":136,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        input_events.insert(tick, vec![","highlight_start":9,"highlight_end":40},{"text":"            InputEvent {","highlight_start":1,"highlight_end":25},{"text":"                tick,","highlight_start":1,"highlight_end":22},{"text":"                source_agent_id: 1,","highlight_start":1,"highlight_end":36},{"text":"                sequence: 1,","highlight_start":1,"highlight_end":29},{"text":"                payload: InputEventPayload::Move { ","highlight_start":1,"highlight_end":52},{"text":"                    x: tick as f32, ","highlight_start":1,"highlight_end":37},{"text":"                    y: (tick * 2) as f32, ","highlight_start":1,"highlight_end":43},{"text":"                    z: 0.0 ","highlight_start":1,"highlight_end":28},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                hash: [0u8; 32],","highlight_start":1,"highlight_end":33},{"text":"                prev_hash: [0u8; 32],","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        ]);","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: unused result of type `Option<Vec<InputEvent>>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mapps/engine/../../tests/phase1_determinism.rs:123:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m         input_events.insert(tick, vec![\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             InputEvent {\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 tick,\n\u001b[1m\u001b[94m126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 source_agent_id: 1,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         ]);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 3 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 3 previous errors; 1 warning emitted\u001b[0m\n\n"}
