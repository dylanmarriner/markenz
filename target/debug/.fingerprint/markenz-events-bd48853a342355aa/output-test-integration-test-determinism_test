{"$message_type":"diagnostic","message":"missing documentation for the crate","code":{"code":"missing_docs","explanation":null},"level":"warning","spans":[{"file_name":"crates/events/tests/determinism_test.rs","byte_start":0,"byte_end":4277,"line_start":1,"line_end":166,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"/**","highlight_start":1,"highlight_end":4},{"text":" * File: crates/events/tests/determinism_test.rs","highlight_start":1,"highlight_end":49},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Purpose: Integration tests for event-based determinism","highlight_start":1,"highlight_end":58},{"text":" * ","highlight_start":1,"highlight_end":4},{"text":" * Phase plan authority: MARKENZ_GOVERNANCE_PHASE_0_REPO_AND_EVENT_LOG_BASELINE.md","highlight_start":1,"highlight_end":83},{"text":" * Section 8.1 \"Determinism Replay Test\"","highlight_start":1,"highlight_end":41},{"text":" */","highlight_start":1,"highlight_end":4},{"text":"","highlight_start":1,"highlight_end":1},{"text":"use markenz_events::{InputEvent, InputEventPayload};","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_event_hash_determinism() {","highlight_start":1,"highlight_end":35},{"text":"    // REQUIREMENT: Same event always produces same hash","highlight_start":1,"highlight_end":57},{"text":"    // This is critical for replay verification","highlight_start":1,"highlight_end":48},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let payload = InputEventPayload::Move {","highlight_start":1,"highlight_end":44},{"text":"        x: 10.0,","highlight_start":1,"highlight_end":17},{"text":"        y: 20.0,","highlight_start":1,"highlight_end":17},{"text":"        z: 30.0,","highlight_start":1,"highlight_end":17},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Create two identical events","highlight_start":1,"highlight_end":35},{"text":"    let event1 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        payload.clone(),","highlight_start":1,"highlight_end":25},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let event2 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        payload.clone(),","highlight_start":1,"highlight_end":25},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // They MUST have identical hashes","highlight_start":1,"highlight_end":39},{"text":"    assert_eq!(event1.hash, event2.hash,","highlight_start":1,"highlight_end":41},{"text":"        \"Identical events must produce identical hashes\");","highlight_start":1,"highlight_end":59},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✓ Event hash is deterministic\");","highlight_start":1,"highlight_end":47},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_hash_chain_linkage() {","highlight_start":1,"highlight_end":31},{"text":"    // REQUIREMENT: Each event must properly link to previous via hash chain","highlight_start":1,"highlight_end":77},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let payload1 = InputEventPayload::Move {","highlight_start":1,"highlight_end":45},{"text":"        x: 1.0,","highlight_start":1,"highlight_end":16},{"text":"        y: 2.0,","highlight_start":1,"highlight_end":16},{"text":"        z: 3.0,","highlight_start":1,"highlight_end":16},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Genesis event (prev_hash = zero)","highlight_start":1,"highlight_end":40},{"text":"    let event1 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        0,","highlight_start":1,"highlight_end":11},{"text":"        0,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        InputEventPayload::BootEvent,","highlight_start":1,"highlight_end":38},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Event 2 links to event 1","highlight_start":1,"highlight_end":32},{"text":"    let event2 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        2,","highlight_start":1,"highlight_end":11},{"text":"        payload1,","highlight_start":1,"highlight_end":18},{"text":"        event1.hash,","highlight_start":1,"highlight_end":21},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify linkage","highlight_start":1,"highlight_end":22},{"text":"    assert!(event2.verify_hash_link(event1.hash),","highlight_start":1,"highlight_end":50},{"text":"        \"Event 2 must properly link to Event 1\");","highlight_start":1,"highlight_end":50},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✓ Hash-chain linkage verified\");","highlight_start":1,"highlight_end":47},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_event_validation_prevents_corruption() {","highlight_start":1,"highlight_end":49},{"text":"    // REQUIREMENT: Event validation prevents invalid states","highlight_start":1,"highlight_end":61},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Test 1: Zero tick for non-boot event should fail","highlight_start":1,"highlight_end":56},{"text":"    let invalid_event = InputEvent::new(","highlight_start":1,"highlight_end":41},{"text":"        0,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        InputEventPayload::Move { x: 1.0, y: 1.0, z: 1.0 },","highlight_start":1,"highlight_end":60},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let result = invalid_event.validate();","highlight_start":1,"highlight_end":43},{"text":"    assert!(result.is_err(),","highlight_start":1,"highlight_end":29},{"text":"        \"Non-boot event with tick=0 should fail validation\");","highlight_start":1,"highlight_end":62},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Test 2: Boot event with non-zero prev_hash should fail","highlight_start":1,"highlight_end":62},{"text":"    let mut boot_event = InputEvent::new(","highlight_start":1,"highlight_end":42},{"text":"        0,","highlight_start":1,"highlight_end":11},{"text":"        0,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        InputEventPayload::BootEvent,","highlight_start":1,"highlight_end":38},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    boot_event.prev_hash = [1u8; 32];  // Corrupt prev_hash","highlight_start":1,"highlight_end":60},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let result = boot_event.validate();","highlight_start":1,"highlight_end":40},{"text":"    assert!(result.is_err(),","highlight_start":1,"highlight_end":29},{"text":"        \"Boot event with non-zero prev_hash should fail validation\");","highlight_start":1,"highlight_end":70},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✓ Event validation enforces integrity constraints\");","highlight_start":1,"highlight_end":67},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_sequence_ordering() {","highlight_start":1,"highlight_end":30},{"text":"    // REQUIREMENT: Events with same tick must be ordered by sequence number","highlight_start":1,"highlight_end":77},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let event1 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        10,","highlight_start":1,"highlight_end":12},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        InputEventPayload::Move { x: 5.0, y: 10.0, z: 0.0 },","highlight_start":1,"highlight_end":61},{"text":"        [0u8; 32],","highlight_start":1,"highlight_end":19},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let event2 = InputEvent::new(","highlight_start":1,"highlight_end":34},{"text":"        11,","highlight_start":1,"highlight_end":12},{"text":"        1,","highlight_start":1,"highlight_end":11},{"text":"        2,","highlight_start":1,"highlight_end":11},{"text":"        InputEventPayload::Move { x: 6.0, y: 11.0, z: 1.0 },","highlight_start":1,"highlight_end":61},{"text":"        event1.hash,","highlight_start":1,"highlight_end":21},{"text":"    ).unwrap();","highlight_start":1,"highlight_end":16},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // Verify sequencing","highlight_start":1,"highlight_end":25},{"text":"    assert!(event1.sequence < event2.sequence,","highlight_start":1,"highlight_end":47},{"text":"        \"Events should have ordered sequences\");","highlight_start":1,"highlight_end":49},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✓ Event sequence ordering maintained\");","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[test]","highlight_start":1,"highlight_end":8},{"text":"fn test_event_schema_completeness() {","highlight_start":1,"highlight_end":38},{"text":"    // REQUIREMENT: All Phase 0 required events are defined","highlight_start":1,"highlight_end":60},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    let boot = InputEventPayload::BootEvent;","highlight_start":1,"highlight_end":45},{"text":"    let tick = InputEventPayload::TickAdvance;","highlight_start":1,"highlight_end":47},{"text":"    let input = InputEventPayload::InputEventSubmitted;","highlight_start":1,"highlight_end":56},{"text":"    let obs = InputEventPayload::ObservationEvent;","highlight_start":1,"highlight_end":51},{"text":"    let snap = InputEventPayload::SnapshotTaken;","highlight_start":1,"highlight_end":49},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    // These should all be creatable","highlight_start":1,"highlight_end":37},{"text":"    let events = vec![","highlight_start":1,"highlight_end":23},{"text":"        InputEvent::new(0, 0, 1, boot, [0u8; 32]),","highlight_start":1,"highlight_end":51},{"text":"        InputEvent::new(1, 0, 2, tick, [1u8; 32]),","highlight_start":1,"highlight_end":51},{"text":"        InputEvent::new(2, 0, 3, input, [2u8; 32]),","highlight_start":1,"highlight_end":52},{"text":"        InputEvent::new(3, 0, 4, obs, [3u8; 32]),","highlight_start":1,"highlight_end":50},{"text":"        InputEvent::new(4, 0, 5, snap, [4u8; 32]),","highlight_start":1,"highlight_end":51},{"text":"    ];","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    assert_eq!(events.len(), 5,","highlight_start":1,"highlight_end":32},{"text":"        \"All Phase 0 required events should be definable\");","highlight_start":1,"highlight_end":60},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    println!(\"✓ Phase 0 event schema is complete\");","highlight_start":1,"highlight_end":52},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"requested on the command line with `-W missing-docs`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: missing documentation for the crate\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/events/tests/determinism_test.rs:1:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m/\u001b[0m /**\n  \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * File: crates/events/tests/determinism_test.rs\n  \u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * \n  \u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m  * Purpose: Integration tests for event-based determinism\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[33m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m     println!(\"✓ Phase 0 event schema is complete\");\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|_^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: requested on the command line with `-W missing-docs`\n\n"}
{"$message_type":"diagnostic","message":"1 warning emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: 1 warning emitted\u001b[0m\n\n"}
